## Stooge sort

> Professors Howard, Find and Howard have proposed a deceptively simple sorting
> algorithm, named stooge sort in their honor, appearing on the following page.
>
> 1. Argue that the call `STOOGE-SORT(A, 1, n)` correctly sorts the array
>    $A[1:n]$.
> 2. Give a recurrence for the worst-case running time of `STOOGE-SORT` and a
>    tight asymptotic ($\Theta$-notation) bound on the worst-case running time.
> 3. Compare the worst-case running time of `STOOGE-SORT` with that of insertion
>    sort, merge sort, heapsort and quicksort. Do the professors deserve tenure?
>
> <span></span>
>
>     STOOGE-SORT(A, p, r):
>       if A[p] > A[r]
>         exchange A[p] with A[r]
>       if p + 1 < r
>         k = ⌊(r - p + 1) / 3⌋     // round down
>         STOOGE-SORT(A, p, r - k)  // first two-thirds
>         STOOGE-SORT(A, p + k, r)  // last two-thirds
>         STOOGE-SORT(A, p, r - k)  // first two-thirds again

This is weird.

### Correctness

Let's do this via informal induction.

In the base case, we can see that it sorts trivially for 0-, 1- and 2-element
arrays. Just for the kicks, with a three element array `[a, b, c]`, it will
first sort `[a, b]` by moving the largest element to the end, then sort `[x, c]`
by moving it again, and finally, properly arrange the first two.

For the inductive step, let's simplify by assuming the number of elements is
evenly divisible by 3, and let's call the thirds `[A, B, C]`. After the first
step we get:

    [A1, B1, C]

We now know that the k biggest elements from `A` and `B` are in `B1`. On the
second step we get:

    [A1, B2, C1]

Now we know that `C1` contains the k biggest elements. We also know they are
sorted. This means that all that is left to get a sorted array is to sort `[A1,
B2]`, which is what the last step does.

### Recurrence

The recurrence here is:

$$ T(n) = 3T(2n/3) + \O(1) $$

I'm not sure if the master theorem applies here, but if it did, with $a = 3$ and
$b = 3/2$, we get about $\Theta(n^{\approx 2.7095})$. More specifically, the
power is $\lg{3}/(\lg{3}-1)$.


### Comparison

(Assuming the previous is correct), this algorithm is worse than all the other
algorithms by far.
