## Stack depth for quicksort

> The `QUICKSORT` algorithm of Section 7.1 contains two recursive calls to
> itself. After `QUICKSORT` calls `PARTITION`, it recursively sorts the low
> side of the partition and then it recursively sorts the right high side of the
> partition. The second recursive call in `QUICKSORT` is not really necessary,
> because the procedure can instead use an iterative control structure. This
> transformation technique, called **tail-recursion elimination**, is provided
> automatically by good compilers. Applying tail-recursion elimination
> transforms `QUICKSORT` into `TRE-QUICKSORT`.
>
>     TRE-QUICKSORT(A, p, r)
>       while p < r
>           // Partition and sort left subarray
>           q = PARTITION(A, p, r)
>           TRE-QUICKSORT(A, p, q - 1)
>           p = q + 1
>
> 1. Argue that `TRE-QUICKSORT(A, 1, n)` correctly sorts the array $A[1:n]$.
>
> Compilers usually execute recursive procedures by using a **stack** that
> contains pertinent information, including the parameter values, for each
> recursive call. The information for the most recent call is at the top of the
> stack, and the information for the initial call is at the bottom. When a
> procedure is called, its information is **pushed** onto the stack, and when it
> terminates, its information is **popped**. Since we assume that array
> parameters are represented by pointers, the information for each procedure
> call on the stack requires $\O(1)$ stack space. The **stack depth** is the
> maximum amount of stack space used at any time during a computation.
>
> <ol start="2" type="a">
>   <li>Describe a scenario in which <code>TRE-QUICKSORT</code>'s stack depth is
>       $\Theta(n)$ on an $n$-element input array.
>   <li>Modify the code for <code>TRE-QUICKSORT</code> so that the worst-case
>        stack depth is $\Theta(\lg{n})$. Maintain the $\O(n\lg{n})$ expected
>        running time of the algorithm.
> </ol>

### Argue correctness

The original version partitions the array and then calls `QUICKSORT` one on
each side. This version does the same, although in a different fashion -
instead of calling `TAIL-RECURSIVE-QUICKSORT`, it just changes `p` and restarts
the loop. It amounts to the same.

This is a straightforward tail-call unrolling.

### Linear stack depth

This will happen whenever partition returns $r$. That is, whenever the array is
sorted.

### Modified algorithm

We are always doing a tail-recursive call on the second partition. We can
modify the algorithm to do the tail recursion on the larger partition. That
way, we'll consume less stack.
